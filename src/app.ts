import type { APIGatewayProxyEventV2, APIGatewayProxyResultV2 } from "aws-lambda"
import { verifyRequest, sendMessage, editMessage, editInteractionResponse } from "./services/discord.js"
import { addEvent, deleteEvent, listEvents, getConfig, saveConfig } from "./services/database.js";
import { InteractionResponseType } from "discord-interactions";
import type { EventOptions, Event } from "./types.js";

/**
 * Lambda handler
 */
export const handler = async (
    event: APIGatewayProxyEventV2
): Promise<APIGatewayProxyResultV2> => {
    // Header, BodyÂèñÂæó
    const signature = event.headers["x-signature-ed25519"] || "";
    const timestamp = event.headers["x-signature-timestamp"] || "";
    const rawBody = event.body || "";

    // ÁΩ≤ÂêçÊ§úË®º
    const isValid = await verifyRequest(rawBody, signature, timestamp);
    if (!isValid) {
        return {
            statusCode: 401,
            body: "Invalid signature",
        };
    }

    // Body„ÅÆÂΩ¢Âºè„ÉÅ„Çß„ÉÉ„ÇØ
    let body;
    try {
        body = JSON.parse(rawBody);
    } catch (err) {
        console.error("Bad Request:", err)
        return {
            statusCode: 400,
            body: "Bad Request"
        }
    }

    // PING„Å∏„ÅÆÂøúÁ≠î (type = 1)
    if (body.type === 1) {
        return buildResponse({
            type: InteractionResponseType.PONG
        })
    }

    // Slash Command„Å∏„ÅÆÂøúÁ≠î (type = 2)
    if (body.type === 2) {
        const commandName = body.data.name;
        
        // Guard check for options array
        if (!Array.isArray(body.data.options) || body.data.options.length === 0) {
            return buildResponse({
                type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
                data: { content: ":warning: „Ç≥„Éû„É≥„Éâ„ÅÆ„Ç™„Éó„Ç∑„Éß„É≥„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ" },
            });
        }
        
        const subCommand = body.data.options[0].name;

        try {
            if (commandName === "events") {
                if (subCommand === "list") {
                    const content = await generateEventListContent(true); // ÁÆ°ÁêÜËÄÖ„Å®„Åó„Å¶Ë°®Á§∫
                    return buildResponse({
                        type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
                        data: { content },
                    });
                }

                if (subCommand === "setup") {
                    const options = body.data.options[0].options.reduce((acc: Record<string, any>, opt: { name: string; value: any }) => {
                        acc[opt.name] = opt.value;
                        return acc;
                    }, {});
                    
                    const adminChannelId = options.admin_channel;
                    const publicChannelId = options.public_channel;
                    
                    // ‰∏ÄÊôÇÂøúÁ≠î
                    const setupPromise = (async () => {
                        try {
                            // ÁÆ°ÁêÜËÄÖÁî®„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ‰ΩúÊàê
                            const adminMessage = await sendMessage(
                                adminChannelId, 
                                "üîß ÁÆ°ÁêÜËÄÖÁî®„Ç§„Éô„É≥„Éà‰∏ÄË¶ß„ÇíË™≠„ÅøËæº„Åø‰∏≠...", 
                                4 // SUPPRESS_EMBEDS
                            );
                            await saveConfig('admin_dashboard_config', adminChannelId, adminMessage.id);
                            
                            // ÂÖ®‰ΩìÁî®„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ‰ΩúÊàê
                            const publicMessage = await sendMessage(
                                publicChannelId, 
                                "üìÖ „Ç§„Éô„É≥„Éà‰∏ÄË¶ß„ÇíË™≠„ÅøËæº„Åø‰∏≠...", 
                                4 // SUPPRESS_EMBEDS
                            );
                            await saveConfig('public_dashboard_config', publicChannelId, publicMessage.id);
                            
                            // „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâÊõ¥Êñ∞
                            await updateDashboardMessage('admin_dashboard_config');
                            await updateDashboardMessage('public_dashboard_config');
                            
                            // „Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥ÂøúÁ≠î„ÇíÊõ¥Êñ∞
                            await editInteractionResponse(
                                body.token,
                                "‚úÖ „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„ÅÆ„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„ÅüÔºÅ"
                            );
                        } catch (err) {
                            console.error("Setup error:", err);
                            await editInteractionResponse(
                                body.token,
                                "‚ùå „Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ"
                            );
                        }
                    })();
                    
                    // Âç≥Â∫ß„Å´ÂøúÁ≠î„Åó„ÄÅ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÂá¶ÁêÜ„ÇíÁ∂ôÁ∂ö
                    setImmediate(() => setupPromise);
                    
                    return buildResponse({
                        type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
                    });
                }

                if (subCommand === "add") {
                    const options = body.data.options[0].options.reduce((acc: Record<string, any>, opt: { name: string; value: any }) => {
                        acc[opt.name] = opt.value;
                        return acc;
                    }, {}) as EventOptions;
                
                    // ‰∏ÄÊôÇÂøúÁ≠î
                    const addPromise = (async () => {
                        try {
                            const newEvent = await addEvent(options);
                            
                            // „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâÊõ¥Êñ∞
                            await updateDashboardMessage('admin_dashboard_config');
                            await updateDashboardMessage('public_dashboard_config');
                            
                            // „Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥ÂøúÁ≠î„ÇíÊõ¥Êñ∞
                            await editInteractionResponse(
                                body.token,
                                `‚úÖ „Ç§„Éô„É≥„Éà **${newEvent.title}**„ÇíËøΩÂä†„Åó„ÄÅ„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü (ID: \`${newEvent.id}\`)`
                            );
                        } catch (err) {
                            console.error("Add event error:", err);
                            await editInteractionResponse(
                                body.token,
                                "‚ùå „Ç§„Éô„É≥„ÉàËøΩÂä†‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ"
                            );
                        }
                    })();
                    
                    // Âç≥Â∫ß„Å´ÂøúÁ≠î„Åó„ÄÅ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÂá¶ÁêÜ„ÇíÁ∂ôÁ∂ö
                    setImmediate(() => addPromise);
                    
                    return buildResponse({
                        type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
                    });
                }

                if (subCommand === "delete") {
                    // Guard checks for nested options
                    const optionsArr = Array.isArray(body.data.options) ? body.data.options : [];
                    const subOptionsArr = optionsArr.length > 0 && Array.isArray(optionsArr[0].options) ? optionsArr[0].options : [];
                    if (subOptionsArr.length === 0 || typeof subOptionsArr[0].value === "undefined") {
                        return buildResponse({
                            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
                            data: { content: ":warning: ÂâäÈô§„Åô„Çã„Ç§„Éô„É≥„ÉàID„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ" },
                        });
                    }
                    const id = subOptionsArr[0].value;
                    
                    // ‰∏ÄÊôÇÂøúÁ≠î
                    const deletePromise = (async () => {
                        try {
                            await deleteEvent(id);
                            
                            // „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâÊõ¥Êñ∞
                            await updateDashboardMessage('admin_dashboard_config');
                            await updateDashboardMessage('public_dashboard_config');
                            
                            // „Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥ÂøúÁ≠î„ÇíÊõ¥Êñ∞
                            await editInteractionResponse(
                                body.token,
                                `‚úÖ „Ç§„Éô„É≥„Éà„ÇíÂâäÈô§„Åó„ÄÅ„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü (ID: \`${id}\`)`
                            );
                        } catch (err) {
                            console.error("Delete event error:", err);
                            await editInteractionResponse(
                                body.token,
                                "‚ùå „Ç§„Éô„É≥„ÉàÂâäÈô§‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ"
                            );
                        }
                    })();
                    
                    // Âç≥Â∫ß„Å´ÂøúÁ≠î„Åó„ÄÅ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÂá¶ÁêÜ„ÇíÁ∂ôÁ∂ö
                    setImmediate(() => deletePromise);
                    
                    return buildResponse({
                        type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
                    });
                }
            }
        } catch (err: unknown) {
            if (err instanceof Error) {
                console.error(err.message, err.stack);
            } else {
                console.error("Unknown error:", err);
            }
            return buildResponse({
                type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
                data: { content: ":warning: „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü" },
            });
        }
    }

    return { statusCode: 404, body: "Not Found" };
};

/**
 * „Ç§„Éô„É≥„Éà‰∏ÄË¶ß„Çí„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Åó„Å¶Ëøî„ÅôÂÖ±ÈÄöÈñ¢Êï∞
 */
const generateEventListContent = async (isAdmin: boolean): Promise<string> => {
    const events = await listEvents();
    
    // Ë®≠ÂÆöID„ÅßÂßã„Åæ„Çã„Ç¢„Ç§„ÉÜ„É†„ÅØÈô§Â§ñÔºàÂÆüÈöõ„ÅÆ„Ç§„Éô„É≥„Éà„ÅÆ„Åø„ÇíË°®Á§∫Ôºâ
    const actualEvents = events.filter(item => !item.id.endsWith('_dashboard_config'));
    
    if (actualEvents.length === 0) {
        return ":information_source: ÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Çã„Ç§„Éô„É≥„Éà„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ";
    }

    // Êó•ÊôÇÈ†Ü„Åß„ÇΩ„Éº„Éà
    actualEvents.sort((a, b) => new Date(a.datetime).getTime() - new Date(b.datetime).getTime());

    let content = isAdmin 
        ? "**üîß ÁÆ°ÁêÜËÄÖÁî®„Ç§„Éô„É≥„Éà‰∏ÄË¶ß**\n\n" 
        : "**üìÖ „Ç§„Éô„É≥„Éà‰∏ÄË¶ß**\n\n";

    content += actualEvents.map((event) => {
        let eventText = `**${event.title}** (${event.datetime})`;
        if (isAdmin) {
            eventText += `\nID: \`${event.id}\``;
        }
        if (event.url) {
            eventText += `\n${event.url}`;
        }
        if (event.message_link) {
            eventText += `\n${event.message_link}`;
        }
        return eventText;
    }).join("\n\n");

    return content;
};

/**
 * ÊåáÂÆö„Åï„Çå„Åü„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊõ¥Êñ∞„Åô„ÇãÂÖ±ÈÄöÈñ¢Êï∞
 */
const updateDashboardMessage = async (configId: string): Promise<void> => {
    const config = await getConfig(configId);
    if (!config) {
        console.log(`Configuration ${configId} not found, skipping update.`);
        return;
    }

    const isAdmin = configId === 'admin_dashboard_config';
    const content = await generateEventListContent(isAdmin);
    
    try {
        await editMessage(config.channelId, config.messageId, content);
    } catch (err) {
        console.error(`Failed to update dashboard ${configId}:`, err);
    }
};

/**
 * ResponseÊßãÁØâ„ÅÆ„Éò„É´„Éë„Éº
 */
const buildResponse = (body: object): APIGatewayProxyResultV2 => {
    return {
        statusCode: 200,
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
    };
};
